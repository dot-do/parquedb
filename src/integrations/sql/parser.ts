/**
 * SQL Parser
 *
 * Lightweight SQL parser for SELECT, INSERT, UPDATE, DELETE statements.
 * Designed to handle the SQL generated by Drizzle and Prisma.
 *
 * Uses regex-based parsing for simplicity and zero dependencies.
 * For complex queries, consider using pgsql-ast-parser.
 */

import type {
  SQLStatement,
  SQLSelect,
  SQLInsert,
  SQLUpdate,
  SQLDelete,
  SQLWhere,
  SQLCondition,
  SQLColumn,
  SQLValue,
  SQLOrderBy,
  SQLOperator,
} from './types.js'

// ============================================================================
// Main Parser
// ============================================================================

/**
 * Parse a SQL statement into an AST
 */
export function parseSQL(sql: string): SQLStatement {
  const normalized = sql.trim()
  const upperSQL = normalized.toUpperCase()

  if (upperSQL.startsWith('SELECT')) {
    return parseSelect(normalized)
  } else if (upperSQL.startsWith('INSERT')) {
    return parseInsert(normalized)
  } else if (upperSQL.startsWith('UPDATE')) {
    return parseUpdate(normalized)
  } else if (upperSQL.startsWith('DELETE')) {
    return parseDelete(normalized)
  }

  throw new Error(`Unsupported SQL statement: ${sql.slice(0, 50)}...`)
}

// ============================================================================
// SELECT Parser
// ============================================================================

function parseSelect(sql: string): SQLSelect {
  const result: SQLSelect = {
    type: 'SELECT',
    columns: '*',
    from: '',
  }

  // Extract columns: SELECT ... FROM
  const selectMatch = sql.match(/SELECT\s+(DISTINCT\s+)?(.+?)\s+FROM\s+/i)
  if (!selectMatch || !selectMatch[2]) {
    throw new Error(`Invalid SELECT statement: ${sql}`)
  }

  const columnsStr = selectMatch[2].trim()
  if (columnsStr === '*') {
    result.columns = '*'
  } else {
    result.columns = parseColumnList(columnsStr)
  }

  // Extract table: FROM table
  const fromMatch = sql.match(/FROM\s+["']?(\w+)["']?/i)
  if (!fromMatch || !fromMatch[1]) {
    throw new Error(`Missing FROM clause: ${sql}`)
  }
  result.from = fromMatch[1]

  // Extract WHERE clause
  const whereMatch = sql.match(/WHERE\s+(.+?)(?:\s+ORDER\s+BY|\s+LIMIT|\s+OFFSET|\s*$)/i)
  if (whereMatch && whereMatch[1]) {
    result.where = parseWhere(whereMatch[1])
  }

  // Extract ORDER BY
  const orderMatch = sql.match(/ORDER\s+BY\s+(.+?)(?:\s+LIMIT|\s+OFFSET|\s*$)/i)
  if (orderMatch && orderMatch[1]) {
    result.orderBy = parseOrderBy(orderMatch[1])
  }

  // Extract LIMIT
  const limitMatch = sql.match(/LIMIT\s+(\d+)/i)
  if (limitMatch && limitMatch[1]) {
    result.limit = parseInt(limitMatch[1], 10)
  }

  // Extract OFFSET
  const offsetMatch = sql.match(/OFFSET\s+(\d+)/i)
  if (offsetMatch && offsetMatch[1]) {
    result.offset = parseInt(offsetMatch[1], 10)
  }

  return result
}

// ============================================================================
// INSERT Parser
// ============================================================================

function parseInsert(sql: string): SQLInsert {
  const result: SQLInsert = {
    type: 'INSERT',
    into: '',
    columns: [],
    values: [],
  }

  // Extract table: INSERT INTO table
  const intoMatch = sql.match(/INSERT\s+INTO\s+["']?(\w+)["']?/i)
  if (!intoMatch || !intoMatch[1]) {
    throw new Error(`Invalid INSERT statement: ${sql}`)
  }
  result.into = intoMatch[1]

  // Extract columns: (col1, col2, ...)
  const columnsMatch = sql.match(/\(([^)]+)\)\s+VALUES/i)
  if (columnsMatch && columnsMatch[1]) {
    result.columns = columnsMatch[1].split(',').map((c) => c.trim().replace(/["']/g, ''))
  }

  // Extract values: VALUES (v1, v2, ...)
  const valuesMatch = sql.match(/VALUES\s+\((.+)\)/i)
  if (valuesMatch && valuesMatch[1]) {
    const valuesList = splitValues(valuesMatch[1])
    result.values = [valuesList.map(parseValue)]
  }

  // Extract RETURNING
  const returningMatch = sql.match(/RETURNING\s+(.+)$/i)
  if (returningMatch && returningMatch[1]) {
    const cols = returningMatch[1].trim()
    result.returning = cols === '*' ? '*' : parseColumnList(cols)
  }

  return result
}

// ============================================================================
// UPDATE Parser
// ============================================================================

function parseUpdate(sql: string): SQLUpdate {
  const result: SQLUpdate = {
    type: 'UPDATE',
    table: '',
    set: {},
  }

  // Extract table: UPDATE table
  const tableMatch = sql.match(/UPDATE\s+["']?(\w+)["']?/i)
  if (!tableMatch || !tableMatch[1]) {
    throw new Error(`Invalid UPDATE statement: ${sql}`)
  }
  result.table = tableMatch[1]

  // Extract SET clause: SET col1 = val1, col2 = val2
  const setMatch = sql.match(/SET\s+(.+?)(?:\s+WHERE|\s+RETURNING|\s*$)/i)
  if (!setMatch || !setMatch[1]) {
    throw new Error(`Missing SET clause: ${sql}`)
  }

  const setPairs = splitSetClause(setMatch[1])
  for (const pair of setPairs) {
    const eqIndex = pair.indexOf('=')
    if (eqIndex > 0) {
      const col = pair.slice(0, eqIndex).trim().replace(/["']/g, '')
      const val = pair.slice(eqIndex + 1).trim()
      result.set[col] = parseValue(val)
    }
  }

  // Extract WHERE clause
  const whereMatch = sql.match(/WHERE\s+(.+?)(?:\s+RETURNING|\s*$)/i)
  if (whereMatch && whereMatch[1]) {
    result.where = parseWhere(whereMatch[1])
  }

  // Extract RETURNING
  const returningMatch = sql.match(/RETURNING\s+(.+)$/i)
  if (returningMatch && returningMatch[1]) {
    const cols = returningMatch[1].trim()
    result.returning = cols === '*' ? '*' : parseColumnList(cols)
  }

  return result
}

// ============================================================================
// DELETE Parser
// ============================================================================

function parseDelete(sql: string): SQLDelete {
  const result: SQLDelete = {
    type: 'DELETE',
    from: '',
  }

  // Extract table: DELETE FROM table
  const fromMatch = sql.match(/DELETE\s+FROM\s+["']?(\w+)["']?/i)
  if (!fromMatch || !fromMatch[1]) {
    throw new Error(`Invalid DELETE statement: ${sql}`)
  }
  result.from = fromMatch[1]

  // Extract WHERE clause
  const whereMatch = sql.match(/WHERE\s+(.+?)(?:\s+RETURNING|\s*$)/i)
  if (whereMatch && whereMatch[1]) {
    result.where = parseWhere(whereMatch[1])
  }

  // Extract RETURNING
  const returningMatch = sql.match(/RETURNING\s+(.+)$/i)
  if (returningMatch && returningMatch[1]) {
    const cols = returningMatch[1].trim()
    result.returning = cols === '*' ? '*' : parseColumnList(cols)
  }

  return result
}

// ============================================================================
// WHERE Clause Parser
// ============================================================================

function parseWhere(whereStr: string): SQLWhere {
  const trimmed = whereStr.trim()

  // Handle AND/OR at top level
  // Split on AND/OR but preserve parentheses
  const andParts = splitLogical(trimmed, 'AND')
  if (andParts.length > 1) {
    return {
      type: 'and',
      conditions: andParts.map(parseWhere),
    }
  }

  const orParts = splitLogical(trimmed, 'OR')
  if (orParts.length > 1) {
    return {
      type: 'or',
      conditions: orParts.map(parseWhere),
    }
  }

  // Single condition
  return {
    type: 'condition',
    condition: parseCondition(trimmed),
  }
}

function parseCondition(condStr: string): SQLCondition {
  const trimmed = condStr.trim()

  // Remove outer parentheses if present
  const unwrapped = trimmed.startsWith('(') && trimmed.endsWith(')')
    ? trimmed.slice(1, -1).trim()
    : trimmed

  // Handle IN / NOT IN
  const inMatch = unwrapped.match(/^(.+?)\s+(NOT\s+)?IN\s*\((.+)\)$/i)
  if (inMatch && inMatch[1] && inMatch[3]) {
    const left = parseColumnOrValue(inMatch[1].trim())
    const values = splitValues(inMatch[3]).map(parseValue)
    return {
      left: left as SQLColumn,
      operator: inMatch[2] ? 'NOT IN' : 'IN',
      right: values,
    }
  }

  // Handle IS NULL / IS NOT NULL
  const isMatch = unwrapped.match(/^(.+?)\s+IS\s+(NOT\s+)?NULL$/i)
  if (isMatch && isMatch[1]) {
    const left = parseColumnOrValue(isMatch[1].trim())
    return {
      left: left as SQLColumn,
      operator: isMatch[2] ? 'IS NOT' : 'IS',
      right: { type: 'null', value: null },
    }
  }

  // Handle comparison operators: =, !=, <>, >, >=, <, <=, LIKE, ILIKE
  const opMatch = unwrapped.match(/^(.+?)\s*(!=|<>|>=|<=|=|>|<|ILIKE|LIKE)\s*(.+)$/i)
  if (opMatch && opMatch[1] && opMatch[2] && opMatch[3]) {
    const left = parseColumnOrValue(opMatch[1].trim())
    const operator = normalizeOperator(opMatch[2].trim().toUpperCase())
    const right = parseValue(opMatch[3].trim())
    return {
      left: left as SQLColumn,
      operator,
      right,
    }
  }

  throw new Error(`Cannot parse condition: ${condStr}`)
}

// ============================================================================
// Helper Functions
// ============================================================================

function parseColumnList(columnsStr: string): SQLColumn[] {
  return splitColumns(columnsStr).map((col) => {
    const trimmed = col.trim()

    // Handle alias: column AS alias or column alias
    const asMatch = trimmed.match(/^(.+?)\s+(?:AS\s+)?["']?(\w+)["']?$/i)
    if (asMatch && asMatch[1] && asMatch[2]) {
      const colPart = asMatch[1].trim()
      const alias = asMatch[2]

      // Handle table.column
      const dotMatch = colPart.match(/^["']?(\w+)["']?\.["']?(\w+)["']?$/)
      if (dotMatch && dotMatch[1] && dotMatch[2]) {
        return { name: dotMatch[2], table: dotMatch[1], alias }
      }
      return { name: colPart.replace(/["']/g, ''), alias }
    }

    // Handle table.column without alias
    const dotMatch = trimmed.match(/^["']?(\w+)["']?\.["']?(\w+)["']?$/)
    if (dotMatch && dotMatch[1] && dotMatch[2]) {
      return { name: dotMatch[2], table: dotMatch[1] }
    }

    return { name: trimmed.replace(/["']/g, '') }
  })
}

function parseOrderBy(orderStr: string): SQLOrderBy[] {
  return orderStr.split(',').map((part) => {
    const trimmed = part.trim()
    const match = trimmed.match(/^["']?(\w+)["']?(?:\s+(ASC|DESC))?$/i)
    if (!match || !match[1]) {
      throw new Error(`Invalid ORDER BY: ${part}`)
    }
    return {
      column: match[1],
      direction: (match[2]?.toUpperCase() as 'ASC' | 'DESC') || 'ASC',
    }
  })
}

function parseValue(valStr: string): SQLValue {
  const trimmed = valStr.trim()

  // Parameter placeholder: $1, $2, ?
  if (trimmed.startsWith('$')) {
    const index = parseInt(trimmed.slice(1), 10)
    return { type: 'parameter', value: undefined, paramIndex: index - 1 }
  }
  if (trimmed === '?') {
    return { type: 'parameter', value: undefined, paramIndex: -1 } // positional
  }

  // NULL
  if (trimmed.toUpperCase() === 'NULL') {
    return { type: 'null', value: null }
  }

  // Boolean
  if (trimmed.toUpperCase() === 'TRUE') {
    return { type: 'boolean', value: true }
  }
  if (trimmed.toUpperCase() === 'FALSE') {
    return { type: 'boolean', value: false }
  }

  // String: 'value' or "value"
  if ((trimmed.startsWith("'") && trimmed.endsWith("'")) ||
      (trimmed.startsWith('"') && trimmed.endsWith('"'))) {
    return { type: 'string', value: trimmed.slice(1, -1) }
  }

  // Number
  const num = Number(trimmed)
  if (!isNaN(num)) {
    return { type: 'number', value: num }
  }

  // Assume it's a column reference or unquoted string
  return { type: 'string', value: trimmed }
}

function parseColumnOrValue(str: string): SQLColumn | SQLValue {
  const trimmed = str.trim()

  // Check if it's a value (string, number, param)
  if (trimmed.startsWith("'") || trimmed.startsWith('"') ||
      trimmed.startsWith('$') || trimmed === '?' ||
      !isNaN(Number(trimmed))) {
    return parseValue(trimmed)
  }

  // It's a column
  const dotMatch = trimmed.match(/^["']?(\w+)["']?\.["']?(\w+)["']?$/)
  if (dotMatch && dotMatch[1] && dotMatch[2]) {
    return { name: dotMatch[2], table: dotMatch[1] }
  }
  return { name: trimmed.replace(/["']/g, '') }
}

function normalizeOperator(op: string): SQLOperator {
  if (op === '<>') return '!='
  return op as SQLOperator
}

function splitLogical(str: string, keyword: 'AND' | 'OR'): string[] {
  const parts: string[] = []
  let depth = 0
  let lastIndex = 0

  // Simple split that respects parentheses depth
  for (let i = 0; i < str.length; i++) {
    if (str[i] === '(') depth++
    else if (str[i] === ')') depth--

    // Check for keyword at depth 0
    if (depth === 0) {
      const remaining = str.slice(i)
      const keywordMatch = remaining.match(new RegExp(`^\\s+${keyword}\\s+`, 'i'))
      if (keywordMatch) {
        parts.push(str.slice(lastIndex, i).trim())
        i += keywordMatch[0].length - 1
        lastIndex = i + 1
      }
    }
  }

  parts.push(str.slice(lastIndex).trim())
  return parts.filter((p) => p.length > 0)
}

function splitColumns(str: string): string[] {
  const parts: string[] = []
  let depth = 0
  let current = ''

  for (const char of str) {
    if (char === '(' || char === '[') depth++
    else if (char === ')' || char === ']') depth--

    if (char === ',' && depth === 0) {
      parts.push(current.trim())
      current = ''
    } else {
      current += char
    }
  }

  if (current.trim()) {
    parts.push(current.trim())
  }

  return parts
}

function splitValues(str: string): string[] {
  const parts: string[] = []
  let depth = 0
  let current = ''
  let inString = false
  let stringChar = ''

  for (let i = 0; i < str.length; i++) {
    const char = str[i]

    // Track string boundaries
    if ((char === "'" || char === '"') && str[i - 1] !== '\\') {
      if (!inString) {
        inString = true
        stringChar = char
      } else if (char === stringChar) {
        inString = false
      }
    }

    if (!inString) {
      if (char === '(') depth++
      else if (char === ')') depth--

      if (char === ',' && depth === 0) {
        parts.push(current.trim())
        current = ''
        continue
      }
    }

    current += char
  }

  if (current.trim()) {
    parts.push(current.trim())
  }

  return parts
}

function splitSetClause(str: string): string[] {
  // Similar to splitValues but handles col = val pairs
  const parts: string[] = []
  let depth = 0
  let current = ''
  let inString = false
  let stringChar = ''

  for (let i = 0; i < str.length; i++) {
    const char = str[i]

    if ((char === "'" || char === '"') && str[i - 1] !== '\\') {
      if (!inString) {
        inString = true
        stringChar = char
      } else if (char === stringChar) {
        inString = false
      }
    }

    if (!inString) {
      if (char === '(') depth++
      else if (char === ')') depth--

      if (char === ',' && depth === 0) {
        parts.push(current.trim())
        current = ''
        continue
      }
    }

    current += char
  }

  if (current.trim()) {
    parts.push(current.trim())
  }

  return parts
}
