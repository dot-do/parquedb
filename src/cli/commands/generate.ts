/**
 * Generate Command
 *
 * Generate typed ParqueDB exports from parquedb.config.ts
 *
 * Usage:
 *   parquedb generate
 *   parquedb generate --output src/db.ts
 */

import * as fs from 'fs'
import * as path from 'path'
import { print, printError, printSuccess, type ParsedArgs } from '../types'
import { loadConfig } from '../../config'
import type { DBSchema, CollectionSchemaWithLayout } from '../../db'

// =============================================================================
// Command Implementation
// =============================================================================

/**
 * Execute the generate command
 */
export async function generateCommand(args: ParsedArgs): Promise<number> {
  try {
    // Show help if requested
    if (args.options.help) {
      printGenerateHelp()
      return 0
    }

    // Parse command-line arguments
    const outputPath = parseOutputPath(args)

    // Load config file
    const config = await loadConfig()
    if (!config) {
      printError('No parquedb.config.ts found.')
      print('')
      print('Create a config file:')
      print('')
      print('  // parquedb.config.ts')
      print('  import { defineConfig } from "parquedb/config"')
      print('')
      print('  export default defineConfig({')
      print('    schema: {')
      print('      User: { email: "string!#", name: "string" }')
      print('    }')
      print('  })')
      return 1
    }

    if (!config.schema) {
      printError('No schema defined in parquedb.config.ts')
      print('')
      print('Add a schema to your config:')
      print('')
      print('  export default defineConfig({')
      print('    schema: {')
      print('      User: { email: "string!#", name: "string" }')
      print('    }')
      print('  })')
      return 1
    }

    // Generate the types file
    const code = generateTypedExports(config.schema, outputPath)

    // Write the output
    const outputDir = path.dirname(outputPath)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    fs.writeFileSync(outputPath, code, 'utf-8')
    printSuccess(`Generated typed exports at ${outputPath}`)

    print('')
    print('Usage:')
    print(`  import { db, sql } from './${path.relative(process.cwd(), outputPath).replace(/\.ts$/, '')}'`)
    print('')
    print('  // Fully typed!')
    print('  await db.User.create({ email: "alice@example.com", name: "Alice" })')
    print('  await db.User.find({ email: "alice@example.com" })')

    return 0
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    printError(message)
    return 1
  }
}

// =============================================================================
// Code Generation
// =============================================================================

/**
 * Generate TypeScript code with typed exports
 */
function generateTypedExports(schema: DBSchema, outputPath: string): string {
  const collectionNames = Object.keys(schema)
  const typedCollections: string[] = []
  const interfaces: string[] = []

  for (const name of collectionNames) {
    const collectionSchema = schema[name]
    if (collectionSchema === 'flexible') {
      continue
    }

    // Generate interface for this collection
    const interfaceCode = generateCollectionInterface(name, collectionSchema as CollectionSchemaWithLayout)
    interfaces.push(interfaceCode)
    typedCollections.push(name)
  }

  // Compute relative path from output file to config file
  const outputDir = path.dirname(path.resolve(outputPath))
  const configPath = path.resolve('parquedb.config')
  let relativeConfigPath = path.relative(outputDir, configPath)

  // Ensure it starts with ./ for relative imports
  if (!relativeConfigPath.startsWith('.')) {
    relativeConfigPath = './' + relativeConfigPath
  }

  // Generate the full file
  return `/**
 * Generated ParqueDB typed exports
 *
 * Auto-generated by: parquedb generate
 * Config file: parquedb.config.ts
 *
 * DO NOT EDIT - regenerate with: parquedb generate
 */

import { DB, type DBInstance as BaseDBInstance } from 'parquedb'
import type { Entity, EntityRef, Filter, UpdateOperators, FindOptions, GetOptions, PaginatedResult } from 'parquedb'

// =============================================================================
// Entity Types
// =============================================================================

${interfaces.join('\n\n')}

// =============================================================================
// Collection Types
// =============================================================================

${typedCollections.map(name => generateCollectionType(name)).join('\n\n')}

// =============================================================================
// Typed Database Interface
// =============================================================================

export interface TypedDB extends BaseDBInstance {
${typedCollections.map(name => `  ${name}: Typed${name}Collection`).join('\n')}
}

// =============================================================================
// Typed Exports
// =============================================================================

// Import config from config file
import config from '${relativeConfigPath}'

/**
 * Typed ParqueDB instance configured from parquedb.config.ts
 *
 * @example
 * \`\`\`typescript
 * import { db, sql } from './db'
 *
 * // Fully typed!
 * await db.User.create({ email: 'alice@example.com', name: 'Alice' })
 * const users = await db.User.find({ status: 'active' })
 * \`\`\`
 */
export const db = DB(config.schema ?? { schema: 'flexible' }) as TypedDB

/**
 * SQL executor for raw queries
 *
 * @example
 * \`\`\`typescript
 * const users = await sql\`SELECT * FROM users WHERE age > \${21}\`
 * \`\`\`
 */
export const sql = db.sql
`
}

/**
 * Generate interface for a collection's entity type
 */
function generateCollectionInterface(name: string, schema: CollectionSchemaWithLayout): string {
  const fields: string[] = []

  for (const [fieldName, fieldDef] of Object.entries(schema)) {
    // Skip $-prefixed config keys
    if (fieldName.startsWith('$')) continue
    if (typeof fieldDef !== 'string') continue

    const tsType = fieldDefToTypeScript(fieldDef)
    const optional = fieldDef.includes('?') || !fieldDef.includes('!') ? '?' : ''

    fields.push(`  ${fieldName}${optional}: ${tsType}`)
  }

  return `/**
 * ${name} entity type
 */
export interface ${name}Entity extends Entity {
  $type: '${name}'
${fields.join('\n')}
}

/**
 * ${name} input type (for create/update)
 */
export interface ${name}Input {
${fields.map(f => f.replace(': ', '?: ')).join('\n')}
}`
}

/**
 * Generate typed collection interface
 */
function generateCollectionType(name: string): string {
  return `/**
 * Typed ${name} collection
 */
export interface Typed${name}Collection {
  create(input: ${name}Input): Promise<${name}Entity>
  get(id: string, options?: GetOptions): Promise<${name}Entity | null>
  find(filter?: Filter<${name}Entity>, options?: FindOptions): Promise<${name}Entity[]>
  findOne(filter?: Filter<${name}Entity>, options?: FindOptions): Promise<${name}Entity | null>
  findPaginated(filter?: Filter<${name}Entity>, options?: FindOptions): Promise<PaginatedResult<${name}Entity>>
  update(id: string, update: UpdateOperators<${name}Entity> | Partial<${name}Input>): Promise<${name}Entity>
  updateMany(filter: Filter<${name}Entity>, update: UpdateOperators<${name}Entity>): Promise<number>
  delete(id: string): Promise<boolean>
  deleteMany(filter: Filter<${name}Entity>): Promise<number>
  count(filter?: Filter<${name}Entity>): Promise<number>
  exists(filter: Filter<${name}Entity>): Promise<boolean>
}`
}

/**
 * Convert field definition to TypeScript type
 */
function fieldDefToTypeScript(fieldDef: string): string {
  // Remove modifiers (!, ?, #, etc.)
  const baseType = fieldDef
    .replace(/[!?#@]/g, '')
    .replace(/\[\]/g, '')
    .trim()

  // Handle relationships
  if (fieldDef.includes('->') || fieldDef.includes('<-')) {
    const isArray = fieldDef.includes('[]')
    return isArray ? 'EntityRef[]' : 'EntityRef'
  }

  // Map to TypeScript types
  const typeMap: Record<string, string> = {
    string: 'string',
    text: 'string',
    int: 'number',
    integer: 'number',
    float: 'number',
    double: 'number',
    number: 'number',
    boolean: 'boolean',
    bool: 'boolean',
    date: 'Date',
    datetime: 'Date',
    timestamp: 'Date',
    json: 'unknown',
    variant: 'unknown',
    any: 'unknown',
  }

  const tsType = typeMap[baseType.toLowerCase()] ?? 'unknown'

  // Handle arrays
  if (fieldDef.includes('[]')) {
    return `${tsType}[]`
  }

  return tsType
}

// =============================================================================
// Argument Parsing
// =============================================================================

/**
 * Parse output path from args
 */
function parseOutputPath(args: ParsedArgs): string {
  // Check for --output flag
  const rawArgs = process.argv.slice(2)
  for (let i = 0; i < rawArgs.length; i++) {
    const arg = rawArgs[i]
    if (arg === '--output' || arg === '-o') {
      return rawArgs[++i] ?? 'src/db.generated.ts'
    }
  }

  // Check positional arg
  if (args.args[0]) {
    return args.args[0]
  }

  // Default output path
  return 'src/db.generated.ts'
}

// =============================================================================
// Help
// =============================================================================

/**
 * Print generate command help
 */
function printGenerateHelp(): void {
  print(`
ParqueDB Generate

Generate typed database exports from parquedb.config.ts

USAGE:
  parquedb generate [options]

OPTIONS:
  -o, --output <path>     Output file path (default: src/db.generated.ts)
  -h, --help              Show this help message

EXAMPLES:
  # Generate with defaults
  parquedb generate

  # Custom output path
  parquedb generate --output lib/database.ts

  # Or specify as positional arg
  parquedb generate src/db.ts

CONFIG FILE:
  Requires parquedb.config.ts with a schema:

    import { defineConfig } from 'parquedb/config'

    export default defineConfig({
      storage: { type: 'fs', path: './data' },
      schema: {
        User: {
          email: 'string!#',
          name: 'string',
          age: 'int?'
        },
        Post: {
          title: 'string!',
          content: 'text',
          author: '-> User'
        }
      }
    })

GENERATED OUTPUT:
  The generated file exports:

    import { db, sql } from './db.generated'

    // Fully typed collections
    await db.User.create({ email: 'alice@example.com', name: 'Alice' })
    const users = await db.User.find({ status: 'active' })

    // SQL queries
    const results = await sql\`SELECT * FROM users WHERE age > \${21}\`
`)
}
